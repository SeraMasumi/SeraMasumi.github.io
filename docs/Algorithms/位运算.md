---
layout: default
title: 位运算相关问题
nav_order: 6
---

# 位运算

Java中十进制转二进制：`Integer.toBinaryString(int n) ;`

---

**与 and &**

**都是1才为1，有0就是0.**

ex: 判断power of 2

如果一个数是`2`的次幂，则其二进制中只有一位为`1`其他为`0`，将其减`1`获得的值刚好`1`全部变为`1`,`1`变为`0`，此时做与运算，则结果为`0`，即可通过结果是否为`0`判断是否为`2`的次幂。

```java
//24 ： 0001 1000  23 : 0000 0111 ,  24 & 23 = 0001 1000 & 0001 0111 = 16
24 & (24 - 1)     //结果不为0 ， 不是2的次幂
//64 : 0100 0000    63 : 0011 1111  , 64 & 63 = 0100 0000 & 0011 1111 =0
64 & (64 - 1)   //结果为0 ， 是2的次幂
```

ex: 判断power of 4

要判断是否是`4`的次幂，首先第一条件是要满足2的次幂，也就是只存在一位为`1`，其次是`1`的位置，必须是偶数的`(16 , 4 , 1 的二进制分别为 0001 0000 , 0000 0010 , 0000 , 0001 )`,以此类推可以得到`.....0101 0101`的单元素子集一定是4的次幂，再已经判断是2的次幂满足的之存在单个`1`的情况下，与`......0101 0101`做与运算，结果为其本身，则1的位置是偶数位，即为4的次幂.

```java
//（需要排除0的存在）
public class Solution {
    public boolean isPowerOfFour(int num) {
        if(num<1){
            return false ;
        }
        return ((num & (num - 1)) == 0)&&((num & 0x55555555) == num);
    }
}
```

ex: 判断奇偶

如果一个数为奇数， 则 二进制最后一位一定为`1` ，与`1`与运算，则结果为`1` ，如果为偶数，最后一位为`0` ，与1与运算结果为`0`。

```java
24 & 1 // 结果为0，是偶数。
```

---

**或 or |**

有一个1就是1

---

**非 not ~**

ex: 获取负数，即各位取反末尾加1

```java
-24 = ~24+1
```

---

**异或 XOR ^**

**一样为0，不同为1**

无第三个参数交换两个数的值

• If we take XOR of zero and some bit, it will return that bit

 	a ^ 0 = a

• If we take XOR of two same bits, it will return 0

 	a ^ a = 0

• a ^ b ^ a = (a ^ a) ^ b = 0 ^ b = b

```java
int a = 10 , b = 20 ;
a = a ^ b ;
b = a ^ b ;
a = a ^ b ;
// 结果 ： a = 20 , b = 10
```

---

**移位** 

左移<< 乘以2的b次方 （翻倍）可能会溢出发生符号改变？

```java
a << b // a * 2^b
```

右移>> 除以2的b次方 （减半）

若左操作数是正数，则高位补“0”，若左操作数是负数，则高位补“1”，这叫做符号位扩展（保留符号位，sign extension ），在进行右移操作时用来保持负数的符号。

```java
a >> b // a / 2^b
```

无符号右移>>> 忽略了符号位扩展，0补最高位

---

例题 